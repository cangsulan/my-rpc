# 基于 Etcd + Vert.x 的RPC框架

## 轻量级RPC框架

- **语言**：Java
- **JDK 版本**：11
- **构建工具**：Maven
- **Web 服务器**：Vert.x（使用HTTP通信）
- **服务注册中心**：Etcd、ZooKeeper（可选）
- **Spring Boot**：2.6.13
- **相关依赖**：
  - **Hutool**：用于处理HTTP请求（`HTTPRequest`），实现简单定时任务（`CronUtil.schedule`）
  - **Guava-Retrying**：用于实现重试机制。
  - **Curator**：用于基于 Zookeeper 的服务发现。
  - **Jetcd**：用于与 Etcd 作为分布式键值存储进行交互。
  - **SnakeYAML**：用于解析和处理 YAML 配置文件。
  - **Jackson-Databind**：用于 JSON 序列化和反序列化。
  - **Hessian**：用于基于 RPC 的对象序列化。
  - **Kryo**：用于高性能对象序列化。
  - **EasyRandom**：用于在测试或模拟场景中生成虚假数据。
  - **Caffeine**：本地缓存，用于缓存 消费端的可调用注册服务列表，减少从注册中心拉取服务列表的次数



## 项目结构

```
my-rpc/
│
├── my-spring-boot-starter/               # 便于使用的启动包，用自定义注解封装了my-rpc-core
│
├── example-springboot-consumer/              # 用于测试，基于注解的 服务消费者 
│
├──example-springboot-provider/               # 用于测试，基于注解的 服务提供者
│
├── example-consumer/               # 用于测试，服务消费者
│
├── example-provider/               # 用于测试，服务提供者
│
├── my-rpc-core/             # 核心模块，是RPC框架的核心底层实现
│
├── my-rpc-easy/            # 一个简易的rpc过程实现，用于早期开发和测试
|
├── my-rpc-common/ 			# 用于测试，放测试用的实体类和方法接口
│
└── pom.xml                        
```



## 项目编写过程遇到的问题

这种轮子项目写起来确实对系统设计的要求高很多，

1. **环境配置：**

​	这个困扰了我很久，因为etcd在我的windows电脑上运行有问题，不知道为什么，后来转虚拟机了，还是linux方便	

​	首先，etcd 我放在linux虚拟机中了，但在windows环境下的idea写代码时，发现无法正确连接

​	解决方法：

​	如下，etcd监听的客户端请求一定要监听0.0.0.0，而不是默认的127.0.0.1，否则外部请求无法被正确处理

```
./etcd --listen-client-urls http://0.0.0.0:2379 --advertise-client-urls http://127.0.0.1:2379
```

​	然后是，zookeeper，这个我之前没接触过，但依靠搜索引擎和AI辅助，我还是把环境弄好了，用docker部署



2. **陌生方式的实现：**

   这个项目中用自定义SPI机制，实现了多种模块的可选和自定义，比如：注册中心、序列化器、重试策略、容错策略、负载均衡策略。

   其中，序列化器中，除了我们熟悉的 JDK方式 和 json方式，还有kryo、hessian等方式，后两种之前没接触过，通过ai和参考别人的经验，也是成功写出来了（虽然我并不理解底层原理）

   其中，zookeeper方式的注册中心，也是靠ai和参考别人，测试是能用的，但具体会不会出问题，是否可靠就没测了，我把重点放在基于etcd来实现注册中心

   

3. **基于ai来实现的功能**：

   有一个功能我基本都是靠ai来实现的，就是：同时支持properties、json、yaml等多种配置文件的读取

   这个功能吧，其实我看有人是用hutool的Prop来实现对properties配置文件的读取，我一开始是这样写的，然后让ai帮我实现了json和yaml配置文件的读取

   但后来发现，这和hutool的那种方式不兼容，主要是hutool的那个是读取File文件，而当我用其他模块来引入rpc框架时，发现文件的位置是有问题的，也就是说读取不到文件，因为hutool底层是做了处理的，但我用ai实现的另2种方式是没有处理的。

   所以，后来干脆放弃了hutool的方式，全用ai的代码来写（这方面，GPT5完全可以信赖）

   后来，测试发现没问题，也支持嵌套结构的读取

   

4. **一些debug经历**：

   一次最久的debug经历是：

   对caffeine缓存功能的测试，我发现本地缓存无法正常使用，存在读取不到、无法删除的问题

   后来，打断点、控制台打日志的方式 反复对比，发现是代码中缓存用的key的不一致导致的

   前后代码因为传参的不同，用的key字符串有点小区别，需要进行特殊处理

   于是我编写了一个静态的工具方法，用来转换key

   其实，看上去很简单的bug，为什么花了很多时间呢，因为我的虚拟机网络老是出问题，桥接模式下连接不稳定（因为我开了梯子用来问ai），所以经常出现etcd连接问题，所以花了较多时间

   这个过程中，测试发现问题 --> 总结现象 --> 找到对应代码 -->日志+断点调试 -->找到原因 --> 着手解决 -->再次测试

   我对于 本地缓存caffeine 的使用过程有了更详细直观的理解。



## 项目目前实现的主要功能 及 缺陷

通过我的commit的描述可以基本了解这个框架的主要功能：

1. 基于jdk动态代理 发送http请求
2. 基于Vert.x的web请求处理
3. 简单实现了 双检索单例模式的 配置懒加载（虽然好像没怎么用到）
4. 基于etcd的注册中心（可选zookeeper）（心跳机制、下线机制）
5.  自定义SPI机制，配合配置文件，实现框架自定义开发
6. 支持多种 序列化方式（json、jdk、kryo、hessian）
7. 支持多种 重试机制（不重试、固定间隔3次尝试）
8. 支持多种 容错机制（快速失败、静默处理、尝试其他节点、服务降级）
9. 支持 负载均衡，多种算法（简单随机、轮询、一致性Hash算法）
10. 基于caffeine的本地缓存
11. 支持多种配置文件的读取（优先级：yaml、properties、json）
12. 支持接口Mock代理，快速返回假数据（主要用于方便开发）
13. 配合SpringBoot和自定义注解封装启动包，简易使用



一些缺陷和遗憾：

1. 少部分代码没有实现（容错机制的 服务降级 来不及写，我的思路是：支持用户自己写降级类实现，或者 调用 Mock 方式来返回假数据）
2. 只支持HTTP协议通信（我看网上有基于tpc自定义协议来通信，但具体效果其实不见得有http高效，想要手搓一个高效完备的自定义协议还是有点麻烦的）
3. 负载均衡算法存在并发风险（一致性hash算法用的treeMap类虽然不是静态，但在配置中用了缓存来复用对象，所以可以看做单例，所以是存在并发安全风险的，解决方法：这个类不加入缓存，变成多例）
4. 一致性Hash算法 的可靠性和效果 高度依赖于 所用的hash算法，我只是简单用了hashcode()方法，生产环境 要用 更好 分布更均匀 的哈希函数
5. 很多代码的可靠性未经过大量测试和压测（毕竟只是一个学习练手的项目，并非生产项目，要用的话还是用比较知名和经受市场考验的RPC框架吧，比如：Dubbo）

​	